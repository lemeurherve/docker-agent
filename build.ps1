[CmdletBinding()]
Param(
    [Parameter(Position = 1)]
    # Default build.ps1 target
    [String] $Target = 'build',
    # Remoting version to include
    [String] $RemotingVersion = '3345.v03dee9b_f88fc',
    # Type of agent ("agent" or "inbound-agent")
    [String] $AgentType = '',
    # Windows flavor and windows version to build
    [String] $ImageType = 'nanoserver-ltsc2019',
    # Image build number
    [String] $BuildNumber = '1',
    # Generate a docker compose file even if it already exists
    [switch] $OverwriteDockerComposeFile = $false,
    # Print the build and publish command instead of executing them if set
    [switch] $DryRun = $false,
    # Output debug info for tests: 'empty' (no additional test output), 'debug' (test cmd & stderr outputed), 'verbose' (test cmd, stderr, stdout outputed)
    [String] $TestsDebug = ''
)

$ErrorActionPreference = 'Stop'
$ProgressPreference = 'SilentlyContinue' # Disable Progress bar for faster downloads
$LogCommandLifecycleEvent = $true

if (![String]::IsNullOrWhiteSpace($env:TESTS_DEBUG)) {
    $TestsDebug = $env:TESTS_DEBUG
}
$env:TESTS_DEBUG = $TestsDebug

if (![String]::IsNullOrWhiteSpace($env:AGENT_TYPE)) {
    $AgentType = $env:AGENT_TYPE
}

# $AgentTypes = @('agent', 'inbound-agent')
$AgentTypes = @('inbound-agent')
if ($AgentType -ne '' -and $AgentType -in $AgentTypes) {
    $AgentTypes = @($AgentType)
}

if (![String]::IsNullOrWhiteSpace($env:REMOTING_VERSION)) {
    $RemotingVersion = $env:REMOTING_VERSION
}

if (![String]::IsNullOrWhiteSpace($env:BUILD_NUMBER)) {
    $BuildNumber = $env:BUILD_NUMBER
}

if (![String]::IsNullOrWhiteSpace($env:IMAGE_TYPE)) {
    $ImageType = $env:IMAGE_TYPE
}

# Ensure constant env vars used in docker-bake.hcl are defined
$env:REMOTING_VERSION = "$RemotingVersion"
$env:BUILD_NUMBER = $BuildNumber

# Check for required commands
Function Test-CommandExists {
    # From https://devblogs.microsoft.com/scripting/use-a-powershell-function-to-see-if-a-command-exists/
    Param (
        [String] $command
    )

    $oldPreference = $ErrorActionPreference
    $ErrorActionPreference = 'stop'
    try {
        # Special case to test "docker buildx"
        if ($command.Contains(' ')) {
            Invoke-Expression $command | Out-Null
            Write-Debug "$command exists"
        } else {
            if(Get-Command $command){
                Write-Debug "$command exists"
            }
        }
    }
    Catch {
        "$command does not exist"
    }
    Finally {
        $ErrorActionPreference = $oldPreference
    }
}

# Ex: Test-Image -AgentType inbound-agent -RemotingVersion 3345.v03dee9b_f88fc -ImageName docker.io/jenkins/agent:jdk21-windowsservercore-ltsc2019 -JavaVersion 21.0.7_6
function Test-Image {
    param (
        [String] $AgentType,
        [String] $RemotingVersion,
        [String] $ImageName,
        [String] $JavaVersion
    )

    $imageName = $ImageName -replace 'docker.io/', ''
    $imageNameItems = $imageName.Split(':')
    $imageTag = $imageNameItems[1]

    Write-Host "=== TEST: Testing ${imageName} image:"

    $env:IMAGE_NAME = $imageName
    $env:VERSION = "$RemotingVersion"
    $env:JAVA_VERSION = "$JavaVersion"

    $targetPath = '.\target\{0}\{1}' -f $AgentType, $imageTag
    if (Test-Path $targetPath) {
        Remove-Item -Recurse -Force $targetPath
    }
    New-Item -Path $targetPath -Type Directory | Out-Null
    $configuration.Run.Path = 'tests\{0}.Tests.ps1' -f $AgentType
    $configuration.TestResult.OutputPath = '{0}\junit-results.xml' -f $targetPath
    $TestResults = Invoke-Pester -Configuration $configuration
    $failed = $false
    if ($TestResults.FailedCount -gt 0) {
        Write-Host "There were $($TestResults.FailedCount) failed tests out of $($TestResults.TotalCount) in ${imageName}"
        $failed = $true
    } else {
        Write-Host "There were $($TestResults.PassedCount) passed tests in ${imageName}"
    }

    Remove-Item env:\IMAGE_NAME
    Remove-Item env:\VERSION
    Remove-Item env:\JAVA_VERSION

    return $failed
}

function Initialize-DockerComposeFile {
    param (
        [String] $AgentType,
        [String] $ImageType,
        [String] $DockerComposeFile
    )

    $baseDockerBakeCmd = 'docker buildx bake --progress=plain --file=docker-bake.hcl'

    $items = $ImageType.Split('-')
    $windowsFlavor = $items[0]
    $windowsVersion = $items[1]

    # Override the list of Windows versions taken defined in docker-bake.hcl by the version from image type
    $env:WINDOWS_VERSION_OVERRIDE = $windowsVersion

    # Override the list of agent types defined in docker-bake.hcl by the specified agent type
    $env:WINDOWS_AGENT_TYPE_OVERRIDE = $AgentType

    # Retrieve the targets from docker buildx bake --print output
    # Remove the 'output' section (unsupported by docker compose)
    # For each target name as service key, return a map consisting of:
    # - 'image' set to the first tag value
    # - 'build' set to the content of the bake target
    $yqMainQuery = '''.target[]' + `
        ' | del(.output)' + `
        ' | {(. | key): {\"image\": .tags[0], \"build\": .}}'''
    # Encapsulate under a top level 'services' map
    $yqServicesQuery = '''{\"services\": .}'''

    # - Use docker buildx bake to output image definitions from the "<windowsFlavor>" bake target
    # - Convert with yq to the format expected by docker compose
    # - Store the result in the docker compose file
    $generateDockerComposeFileCmd = ' {0} {1} --print' -f $baseDockerBakeCmd, $windowsFlavor + `
        ' | yq --prettyPrint {0} | yq {1}' -f $yqMainQuery, $yqServicesQuery + `
        ' | Out-File -FilePath {0}' -f $DockerComposeFile

    Write-Host "= PREPARE: Docker compose file generation command`n$generateDockerComposeFileCmd"

    Invoke-Expression $generateDockerComposeFileCmd

    # Remove override
    Remove-Item env:\WINDOWS_VERSION_OVERRIDE
    Remove-Item env:\WINDOWS_AGENT_TYPE_OVERRIDE
}

Test-CommandExists 'docker'
Test-CommandExists 'docker-compose'
Test-CommandExists 'docker buildx'
Test-CommandExists 'yq'

# Sanity checks
Invoke-Expression 'docker info'

# Doc: https://github.com/moby/buildkit/blob/master/docs/windows.md & https://docs.docker.com/build/buildkit/#buildkit-on-windows
function Buildkit-Setup {
    param (
        [Boolean] $InstallContainerd = $false,
        [Boolean] $InstallBuildkitd = $false
    )

    # Ensure Hyper-V and Containers Windows features are enabled
    Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V, Containers -All

    # https://github.com/containerd/containerd/blob/main/docs/getting-started.md#installing-containerd-on-windows
    if ($InstallContainerd) {
        # If containerd previously installed run:
        Stop-Service containerd

        # Download and extract desired containerd Windows binaries
        $Version="1.7.13"	# update to your preferred version
        $Arch = "amd64"	# arm64 also available
        curl.exe -LO https://github.com/containerd/containerd/releases/download/v$Version/containerd-$Version-windows-$Arch.tar.gz
        tar.exe xvf .\containerd-$Version-windows-$Arch.tar.gz

        # Copy
        Copy-Item -Path .\bin -Destination $Env:ProgramFiles\containerd -Recurse -Force

        # add the binaries (containerd.exe, ctr.exe) in $env:Path
        $Path = [Environment]::GetEnvironmentVariable("PATH", "Machine") + [IO.Path]::PathSeparator + "$Env:ProgramFiles\containerd"
        [Environment]::SetEnvironmentVariable( "Path", $Path, "Machine")
        # reload path, so you don't have to open a new PS terminal later if needed
        $Env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")

        # configure
        containerd.exe config default | Out-File $Env:ProgramFiles\containerd\config.toml -Encoding ascii
        # Review the configuration. Depending on setup you may want to adjust:
        # - the sandbox_image (Kubernetes pause image)
        # - cni bin_dir and conf_dir locations
        Get-Content $Env:ProgramFiles\containerd\config.toml

        # Register and start service
        containerd.exe --register-service
        Start-Service containerd
    }

    if ($InstallBuildkitd) {
        ## Download and extract
        $url = "https://api.github.com/repos/moby/buildkit/releases/latest"
        $version = (Invoke-RestMethod -Uri $url -UseBasicParsing).tag_name
        $arch = "amd64" # arm64 binary available too
        curl.exe -fSLO https://github.com/moby/buildkit/releases/download/$version/buildkit-$version.windows-$arch.tar.gz
        # there could be another `.\bin` directory from containerd instructions
        # you can move those
        mv bin bin2
        tar.exe xvf .\buildkit-$version.windows-$arch.tar.gz
        ## x bin/
        ## x bin/buildctl.exe
        ## x bin/buildkitd.exe

        ## Setup buildkitd binaries
        # after the binaries are extracted in the bin directory
        # move them to an appropriate path in your $Env:PATH directories or:
        Copy-Item -Path ".\bin" -Destination "$Env:ProgramFiles\buildkit" -Recurse -Force
        # add `buildkitd.exe` and `buildctl.exe` binaries in the $Env:PATH
        $Path = [Environment]::GetEnvironmentVariable("PATH", "Machine") + `
            [IO.Path]::PathSeparator + "$Env:ProgramFiles\buildkit"
        [Environment]::SetEnvironmentVariable( "Path", $Path, "Machine")
        $Env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + `
            [System.Environment]::GetEnvironmentVariable("Path","User")
    }
}
try {
    Test-CommandExists 'ctr'
} catch {
    Write-Host 'containerd not found'
}
try {
    Test-CommandExists 'buildkitd'
} catch {
    Write-Host 'buildkitd not found'
}
try {
    Buildkit-Setup -InstallContainerd $false -InstallBuildkitd $false
} catch {}
Get-WindowsOptionalFeature -Online

# Docker warmup (TODO: proper improvement incoming to pull only the base images from docker bake/compose file)
Write-Host '= PREPARE: Docker warmup (pull base images)'
$warmupImages = @(
    'mcr.microsoft.com/windows/servercore:ltsc2019',
    'mcr.microsoft.com/powershell:nanoserver-1809',
    'mcr.microsoft.com/windows/nanoserver:ltsc2019'
)

$warmupJobs = @()
foreach ($image in $warmupImages) {
    $warmupJobs += Start-Job -ScriptBlock {
        param($img)
        Write-Host "== PREPARE: pulling $img"
        Invoke-Expression "docker pull $img"
    } -ArgumentList $image
}
# Wait for all pulls to finish
$warmupJobs | ForEach-Object { Receive-Job -Job $_ -Wait; Remove-Job $_ }
Invoke-Expression 'docker images ls --tree'

$testImageFunction = ${function:Test-Image}
$workspacePath = (Get-Location).Path
foreach($agentType in $AgentTypes) {
    $dockerComposeFile = 'build-windows_{0}_{1}.yaml' -f $AgentType, $ImageType
    $baseDockerCmd = 'docker-compose --file={0}' -f $dockerComposeFile
    $baseDockerBuildCmd = '{0} build --parallel' -f $baseDockerCmd

    # Generate the docker compose file if it doesn't exists or if the parameter OverwriteDockerComposeFile is set
    if ((Test-Path $dockerComposeFile) -and -not $OverwriteDockerComposeFile) {
        Write-Host "= PREPARE: The docker compose file '$dockerComposeFile' containing the image definitions already exists."
    } else {
        Write-Host "= PREPARE: Initialize the docker compose file '$dockerComposeFile' containing the image definitions."
        Initialize-DockerComposeFile -AgentType $AgentType -ImageType $ImageType -DockerComposeFile $dockerComposeFile
    }

    Write-Host '= PREPARE: List of images and tags to be processed:'
    Invoke-Expression "$baseDockerCmd config"

    Write-Host '= BUILD: Building all images...'
    switch ($DryRun) {
        $true { Write-Host "(dry-run) $baseDockerBuildCmd" }
        $false { Invoke-Expression $baseDockerBuildCmd }
    }
    Write-Host '= BUILD: Finished building all images.'

    if ($lastExitCode -ne 0) {
        exit $lastExitCode
    }

    if ($target -eq 'test') {
        if ($DryRun) {
            Write-Host '= TEST: (dry-run) test harness'
        } else {
            Write-Host '= TEST: Starting test harness'

            $mod = Get-InstalledModule -Name Pester -MinimumVersion 5.3.0 -MaximumVersion 5.3.3 -ErrorAction SilentlyContinue
            if ($null -eq $mod) {
                Write-Host '= TEST: Pester 5.3.x not found: installing...'
                $module = 'C:\Program Files\WindowsPowerShell\Modules\Pester'
                if (Test-Path $module) {
                    takeown /F $module /A /R
                    icacls $module /reset
                    icacls $module /grant Administrators:'F' /inheritance:d /T
                    Remove-Item -Path $module -Recurse -Force -Confirm:$false
                }
                Install-Module -Force -Name Pester -MaximumVersion 5.3.3
            }

            Write-Host "= TEST: Testing all ${agentType} images..."
            $jdks = Invoke-Expression "$baseDockerCmd config" | yq --unwrapScalar --output-format json '.services' | ConvertFrom-Json

            $testMode = 'sequential'

            if ($testMode -eq 'sequential') {
                # Run Test-Image sequentially for each JDK
                foreach ($jdk in $jdks.PSObject.Properties) {
                    $testFailed = $testFailed -or (Test-Image -AgentType $agentType -RemotingVersion $RemotingVersion -ImageName $jdk.Value.image -JavaVersion $jdk.Value.build.args.JAVA_VERSION)
                }
            } else {
                # Run Test-Image in parallel for each JDK
                $jobs = @()
                foreach ($jdk in $jdks.PSObject.Properties) {
                    $image = $jdk.Value.image
                    $javaVersion = $jdk.Value.build.args.JAVA_VERSION
                    Write-Host "= TEST: Starting ${image} tests in parallel..."
                    $jobs += Start-Job -ScriptBlock {
                        param($anAgentType, $aRemotingVersion, $anImage, $aJavaVersion, $aTestImageFunction, $aWorkspacePath)

                        Write-Host "== TEST: Setting up Pester environment for $anImage testing..."
                        Import-Module Pester
                        $configuration = [PesterConfiguration]::Default
                        $configuration.Run.PassThru = $true
                        $configuration.Run.Path = '{0}\tests' -f $aWorkspacePath
                        $configuration.Run.Exit = $true
                        $configuration.TestResult.Enabled = $true
                        $configuration.TestResult.OutputFormat = 'JUnitXml'
                        $configuration.Output.Verbosity = 'Diagnostic'
                        $configuration.CodeCoverage.Enabled = $false
                        Set-Item -Path Function:Test-Image -Value $aTestImageFunction
                        Set-Location -Path $aWorkspacePath

                        Test-Image -AgentType $anAgentType -RemotingVersion $aRemotingVersion -ImageName $anImage -JavaVersion $aJavaVersion
                    } -ArgumentList $agentType, $RemotingVersion, $image, $javaVersion, $testImageFunction, $workspacePath
                }

                # Wait for all jobs to finish and collect results
                $testFailed = $false
                foreach ($job in $jobs) {
                    $result = Receive-Job -Job $job -Wait
                    if ($result.Failed) {
                        Write-Host "= TEST: Error(s), see the results below"
                        $result.Tests | ConvertTo-Json | Write-Host
                        $testFailed = $true
                    }
                    Remove-Job $job
                }
            }

            # Fail if any test failures
            if ($testFailed -ne $false) {
                Write-Error "Test stage failed for ${agentType}!"
                exit 1
            } else {
                Write-Host "= TEST: stage passed for ${agentType}!"
            }
        }
    }

    if ($target -eq 'publish') {
        Write-Host '= PUBLISH: push all images and tags'
        switch($DryRun) {
            $true { Write-Host "(dry-run) $baseDockerCmd push" }
            $false { Invoke-Expression "$baseDockerCmd push" }
        }

        # Fail if any issues when publising the docker images
        if ($lastExitCode -ne 0) {
            Write-Error '= PUBLISH: failed!'
            exit 1
        }
    }
}

if ($lastExitCode -ne 0) {
    Write-Error 'Build failed!'
} else {
    Write-Host '= Build finished successfully'
}
exit $lastExitCode
